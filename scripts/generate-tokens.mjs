#!/usr/bin/env node
import { promises as fs } from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');

const TOKENS_DIR = path.join(projectRoot, 'tokens');
const OUTPUT_CSS = path.join(projectRoot, 'src', 'styles', 'tokens.css');

function sanitizeSegment(segment) {
  return String(segment)
    .trim()
    .toLowerCase()
    // replace any non-alphanumeric with '-'
    .replace(/[^a-z0-9]+/g, '-')
    // collapse multiple '-'
    .replace(/-+/g, '-')
    // trim leading/trailing '-'
    .replace(/^-|-$/g, '');
}

function toCssVarName(key) {
  return `--${sanitizeSegment(key)}`;
}

async function readJson(filePath) {
  const buf = await fs.readFile(filePath, 'utf8');
  return JSON.parse(buf);
}

function isReference(value) {
  return typeof value === 'string' && /^\{[^}]+\}$/.test(value.trim());
}

function getPath(obj, pathStr) {
  const parts = pathStr.split('.');
  let cur = obj;
  for (const part of parts) {
    if (cur && Object.prototype.hasOwnProperty.call(cur, part)) {
      cur = cur[part];
    } else {
      return undefined;
    }
  }
  return cur;
}

function flattenDictionary(obj, prefix = '', out = {}) {
  for (const [k, v] of Object.entries(obj)) {
    const key = prefix ? `${prefix}.${k}` : k;
    if (v && typeof v === 'object' && !('$value' in v) && !('$type' in v)) {
      flattenDictionary(v, key, out);
    } else if (v && typeof v === 'object' && '$value' in v) {
      out[key] = v.$value;
    } else if (typeof v === 'string') {
      out[key] = v;
    } else if (typeof v === 'number') {
      out[key] = String(v);
    } else if (v && typeof v === 'object') {
      // Leaf objects without $value
      flattenDictionary(v, key, out);
    }
  }
  return out;
}

function deepMerge(...objs) {
  const result = {};
  for (const obj of objs) {
    for (const [k, v] of Object.entries(obj || {})) {
      if (v && typeof v === 'object' && !Array.isArray(v)) {
        result[k] = deepMerge(result[k], v);
      } else {
        result[k] = v;
      }
    }
  }
  return result;
}

function createLookup(lightColors, modeTokens) {
  // Both inputs are nested JSON trees with $value leaves
  return {
    light: flattenDictionary(lightColors),
    mode: flattenDictionary(modeTokens),
  };
}

function resolveAliasString(input, lookup, maxDepth = 10) {
  let value = input;
  let depth = 0;
  while (isReference(value) && depth < maxDepth) {
    const pathStr = value.slice(1, -1); // remove {}
    // Prefer tw colors, then mode tokens
    let resolved = lookup.light[pathStr];
    if (resolved === undefined) resolved = lookup.mode[pathStr];
    if (resolved === undefined) {
      break; // cannot resolve
    }
    value = resolved;
    depth += 1;
  }
  return value;
}

function normalizeColor(val) {
  if (typeof val !== 'string') return String(val);
  const s = val.trim();
  // Ensure hex colors are lowercase
  if (/^#[0-9A-Fa-f]{3,8}$/.test(s)) return s.toLowerCase();
  return s;
}

async function generate() {
  // Ensure output dir exists
  await fs.mkdir(path.dirname(OUTPUT_CSS), { recursive: true });

  // Load sources
  const [uiLight, uiDark, twLightColors, modeTokens] = await Promise.all([
    readJson(path.join(TOKENS_DIR, 'shadcn', 'ui', 'light mode.json')),
    readJson(path.join(TOKENS_DIR, 'shadcn', 'ui', 'dark mode.json')),
    readJson(path.join(TOKENS_DIR, 'tw', 'colors', 'Light.json')),
    readJson(path.join(TOKENS_DIR, 'tokens', 'Mode 1.json')),
  ]);

  const lookup = createLookup(twLightColors, modeTokens);

  // Resolve shadcn/ui variables for light/dark
  const resolveTokenSet = (set) => {
    const out = {};
    for (const [key, obj] of Object.entries(set)) {
      const raw = obj && typeof obj === 'object' && '$value' in obj ? obj.$value : obj;
      const resolved = normalizeColor(resolveAliasString(raw, lookup));
      const varName = toCssVarName(key);
      out[varName] = resolved;
    }
    return out;
  };

  const lightVars = resolveTokenSet(uiLight);
  const darkVars = resolveTokenSet(uiDark);

  // Build TW variables from Light.json
  const twVars = {};
  function emitTwVars(obj, pathParts = []) {
    for (const [k, v] of Object.entries(obj)) {
      if (v && typeof v === 'object' && '$value' in v) {
        const shade = [...pathParts, k].map(sanitizeSegment).join('-');
        const name = `--tw-${shade}`; // e.g. --tw-slate-50
        twVars[name] = normalizeColor(v.$value);
      } else if (v && typeof v === 'object') {
        emitTwVars(v, [...pathParts, k]);
      }
    }
  }
  emitTwVars(twLightColors, []);

  // Compose CSS
  const header = `/*
  This file is auto-generated by scripts/generate-tokens.mjs
  Do not edit manually.
*/`;

  const toCssBlock = (selector, vars) => {
    const lines = Object.entries(vars)
      .map(([name, value]) => `  ${name}: ${value};`)
      .join('\n');
    return `${selector} {\n${lines}\n}`;
  };

  const css = [
    header,
    toCssBlock(':root', { ...lightVars, ...twVars }),
    toCssBlock('.dark', darkVars),
    '',
  ].join('\n\n');

  await fs.writeFile(OUTPUT_CSS, css, 'utf8');
  console.log(`Generated ${path.relative(projectRoot, OUTPUT_CSS)} with ${Object.keys(lightVars).length} light, ${Object.keys(darkVars).length} dark and ${Object.keys(twVars).length} tw vars.`);
}

generate().catch((err) => {
  console.error(err);
  process.exit(1);
});


